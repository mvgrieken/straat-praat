Inleiding: De Straat-Praat-app is een mobiele applicatie bedoeld voor ouders van tieners, om op een leuke manier de jongerenslang (Straat-Praat) te leren begrijpen en gebruiken. Het doel is de taal- en generatiekloof te overbruggen zodat ouders zich beter kunnen verbinden met hun kinderen. De app is heel laagdrempelig vormgegeven, afgestemd op gebruikers met beperkte digitale vaardigheden. De interface is eenvoudig met duidelijke tekst, grote knoppen en intuïtieve navigatie. Waar mogelijk is ook spraakondersteuning voorzien (woorden inspreken en uitspraken beluisteren) zodat ouders die niet gewend zijn te typen of lezen de app moeiteloos kunnen gebruiken. De inhoud van de app wordt continu bijgewerkt om bij te blijven met de snel evoluerende Straat-Praat van jongeren, zonder dat de gebruiker hiervoor handmatig updates hoeft te installeren. Hieronder worden alle functies en modules van de app beschreven conform het ontwerp en de technische specificaties, zodat gecontroleerd kan worden of een implementatie alle ontwerpintenties dekt.

Vertaalfunctie (Straat-Praat ↔ Gewone taal): De kern van de app is de vertaalfunctie die slangwoorden en –zinnen kan omzetten naar standaard Nederlands en omgekeerd. De gebruiker kan in een zoekbalk een term invoeren en krijgt direct de vertaling te zien, met een toelichting of voorbeeldzin voor context. Bijvoorbeeld: voert de ouder “skeer” in, dan toont de app “blut, arm” met een voorbeeldzin als “Ik kan niet mee uiteten, want ik ben skeer (blut).”. Voert men een normaal Nederlands woord in, dan geeft de app het equivalente slangwoord, indien beschikbaar. Er is een duidelijke schakelaar of toggle aanwezig waarmee de gebruiker de richting kiest: “Straat-Praat naar NL” of “NL naar Straat-Praat”, zodat er geen misinterpretatie is over wat er vertaald moet worden. De zoekinterface helpt de gebruiker bij het vinden van het juiste woord: terwijl men typt verschijnen suggesties via auto-aanvullen. Deze suggesties komen tot stand met fuzzy search-logica op de slangwoordenlijst. De invoer wordt genormaliseerd (lowercase, accenten verwijderen, speciale tekens eruit) en er wordt gezocht op overeenkomsten en alternatieve spellingen. Zo worden ook woorden met typefouten of varianten gevonden. Voorbeelden: bij het typen van “bruh” vindt de app “bro”, omdat de normalisatie de “uh” op het eind omzet naar “o” en via een fonetisch algoritme (Double Metaphone) ook klank-overeenkomsten matcht. Dankzij een trigram-index op de database kunnen zelfs woorden met paar letters verschil als suggestie verschijnen. De resultatenlijst laat duidelijk het gevonden woord zien en eventueel of het via een variant is gevonden (bijvoorbeeld een label “gevonden via variant”). Als er geen resultaat is, krijgt de gebruiker een vriendelijke melding dat het woord niet in de lijst staat. Daarbij wordt meteen een optie geboden om het woord als nieuwe term voor te stellen ter toevoeging (zie Community-invoer), of een hint om de spelling te controleren. De vertaalfunctie heeft verder opties om een gevonden woord als favoriet op te slaan (zodat de gebruiker het later kan herbekijken) en om de uitspraak te beluisteren via een audio-icoon. Voor veel slangwoorden is een audio-opname beschikbaar (door een native spreker, opgeslagen als mp3); als die niet beschikbaar is kan de app via tekst-naar-spraak de uitspraak genereren. Bij het tonen van een vertaling wordt dus naast het woord en de betekenis ook een “luister”-knop getoond voor de uitspraak. Invoer via spraak is ook mogelijk: met een microfoonknop kan de gebruiker een slangwoord inspreken, waarna de app de spraak naar tekst omzet (via de native speech-to-text API van het device, bijvoorbeeld SFSpeechRecognizer op iOS of RecognizerIntent op Android) en vervolgens automatisch de vertaling opzoekt. De gehele interactie is ontworpen om zo eenvoudig mogelijk te zijn: één invoerveld en één duidelijke actie om te vertalen, met ondersteuning voor zowel tekst als stem. Edge cases worden netjes afgehandeld: indien een gebruiker een enorme lap tekst invoert (bijvoorbeeld een hele zin of alinea) zal de app dit afkappen of in delen vertalen in plaats van te crashen. Bij een onbekende term die ook met fuzzy search geen match oplevert, blijft de app responsief en toont simpelweg “woord niet gevonden” met de genoemde opties. Ook bij netwerkproblemen (als de app een online zoekservice gebruikt) krijgt de gebruiker een melding dat vertalen nu even niet mogelijk is, in plaats van een leeg scherm. Tot slot is er aandacht voor toegankelijkheid: het lettertype is groot genoeg, contrast is hoog, en alle iconen (zoeken, wisselen van taalrichting, favoriet markeren, audio afspelen) zijn voorzien van labels of tooltips zodat de functie duidelijk is. Deze vertaalfunctie werkt zowel voor losse woorden als hele zinnen; de gebruiker kan bijvoorbeeld een volledige slangzin invoeren en de app geeft een netjes geformuleerde Nederlandse zin terug, of andersom een formele zin omzetten in informele jongerentaal. De implementatie daarvan maakt gebruik van een AI-model (zie verder bij AI-module), zodat ook zinnen contextueel correct vertaald worden.

Woord van de Dag: Om gebruikers spelenderwijs nieuwe slang te leren, biedt de app elke dag automatisch een Woord van de Dag. Dit is een dagelijks geselecteerd slangwoord dat prominent onder de aandacht wordt gebracht, inclusief de betekenis en een voorbeeldzin. Bijvoorbeeld verschijnt er ’s ochtends een kaart of banner: “Woord van de Dag: fleek – perfect, helemaal goed. Voorbeeld: Die outfit is on fleek, die outfit is perfect.” Zonder dat de gebruiker iets hoeft op te zoeken, krijgt hij zo elke dag een hapklare portie nieuwe vocabulaire. Het Woord van de Dag kan op het startscherm van de app getoond worden of in een aparte sectie, maar in elk geval gemakkelijk vindbaar. Eerdere dagelijkse woorden blijven beschikbaar in een geschiedenisoverzicht – bijvoorbeeld een lijst of kalender van de afgelopen 30 dagen – zodat een gebruiker gemiste dagen kan terugkijken of later kan herhalen. Standaard kiest het systeem elke kalenderdag een willekeurig woord uit de slangwoorden-database dat de gebruiker nog niet gezien heeft. Herhaling binnen korte tijd wordt vermeden: de app houdt bij welke woorden recent als dagwoord zijn gebruikt en zorgt dat bijvoorbeeld niet binnen drie maanden hetzelfde woord opnieuw komt. Contentbeheerders kunnen ook ingrijpen in deze selectie (zie Contentbeheer): zij kunnen voor specifieke dagen een bepaald woord instellen, bijvoorbeeld om in te spelen op een trend of actueel begrip. De presentatie van het dagwoord is duidelijk en aantrekkelijk: het slangwoord staat groot in beeld, daaronder de vertaling en eventueel een extra toelichting of weetje, plus een voorbeeldzin. Ook hier kan een audio-icoon staan als er een uitspraak beschikbaar is. De gebruiker kan aangeven dat hij het woord gezien of geleerd heeft (dit kan impliciet gebeuren zodra het scherm geopend is) en kan het woord desgewenst aan zijn favorieten toevoegen. Delen van het Woord van de Dag via andere kanalen (WhatsApp bv. om een andere ouder te laten lachen of leren) is ook mogelijk met een deel-knop. Om gebruikers te attenderen wordt er dagelijks een pushnotificatie verstuurd rond een vast tijdstip (standaard bijvoorbeeld 10:00 uur) met een teaser van het woord. Door op die melding te tikken opent de app direct op het Woord-van-de-Dag scherm. In de notificatie staat bijv.: “Woord van de Dag: skeer. Weet jij wat het betekent? 🤔” (zie ook Pushnotificaties hieronder voor meer). De gebruiker kan in de instellingen aangeven op welk tijdstip hij de dagelijkse melding wil (ochtend, middag of avond), of het helemaal uitzetten. De Woord van de Dag-functie houdt rekening met het niveau van de gebruiker als adaptief leren is ingeschakeld: een beginner krijgt eerder eenvoudige en veelvoorkomende slang als dagwoord, terwijl een gevorderde gebruiker meer unieke of moeilijke termen voorgeschoteld krijgt. Dit is een gewenste uitbreiding; in de eerste versie kan het systeem ook zonder adaptiviteit gewoon random een woord kiezen elke dag. Edge cases: Als iemand de app voor het eerst halverwege de dag opent, krijgt hij meteen het woord van die dag te zien (we wachten niet tot de volgende dag, zo heeft de nieuwe gebruiker direct waarde). Als de gebruiker een tijdje niet inlogt (bijv. een week), tonen we bij terugkeer alleen het woord van vandaag – we gaan niet alle gemiste dagen ineens pushen, om niet te overladen. Die gemiste woorden kan de gebruiker zelf in de geschiedenis terugvinden op eigen tempo. Technisch is er ook rekening gehouden met offline scenario’s: als op het moment dat een nieuw woord van de dag moet laden de telefoon geen internetverbinding heeft, kan de app een eerder gedownloade lijst gebruiken om toch een woord te tonen, of de notificatie uitstellen totdat er weer verbinding is. In het slechtste geval ziet de gebruiker een bericht “Geen nieuw woord beschikbaar – controleer je internetverbinding” in plaats van een blank scherm. Wanneer de verbinding hersteld is, wordt alsnog het actuele woord van vandaag opgehaald. Verder voorkomt de app dubbele meldingen: als een gebruiker al handmatig die dag het woord gezien heeft in de ochtend, en er staat ook een notificatie gepland voor die dag, dan zal de app die notificatie annuleren of aanpassen (“Heb je het Woord van de Dag fleek al gezien?” in plaats van een neutrale aankondiging). Zo raken gebruikers niet in de war of geïrriteerd door overbodige meldingen. De Woord van de Dag-feature is dus ontworpen als dagelijkse leerprikkel die de gebruiker met minimale moeite telkens iets nieuws bijbrengt.

Quiz & Spellen: Naast passief woorden opzoeken biedt de app interactieve quizzen en spelletjes om de slangkennis te toetsen en te laten groeien. In de Straat-Praatquiz beantwoordt de gebruiker vragen over slangwoorden. Een typische quiz bestaat bijvoorbeeld uit 5 of 10 meerkeuzevragen. Een vraag kan zijn: “Wat betekent ‘fleek’?” met opties A) saai, B) perfect, C) boos, D) duur. De gebruiker kiest een antwoord en krijgt direct feedback: bij een goed antwoord verschijnt bijvoorbeeld groen vinkje en “Correct – fleek betekent perfect.”, bij een fout antwoord rood kruis met “Niet juist – fleek betekent perfect, men zegt bv. ‘Je outfit is on fleek’.”. Deze directe terugkoppeling bij elke vraag helpt de gebruiker te leren van fouten op het moment dat ze gemaakt worden. Na feedback gaat de quiz automatisch door naar de volgende vraag. Er zijn variaties in vraagstelling mogelijk: soms wordt het slangwoord getoond en moet de betekenis gekozen worden (Straat-Praat → NL), andere keren wordt een definitie gegeven en moet de gebruiker raden welk slangwoord daarbij hoort (NL → Straat-Praat). In principe houden we het bij meerkeuzevragen omdat dat voor de meeste gebruikers het makkelijkst is, al kan voor gevorderden eventueel ook een open invoervraag of een invuloefening (woord in een zin plaatsen) toegevoegd worden. Behalve de quiz kunnen er ook kleine spelletjes zijn voor de afwisseling en het plezier. Denk aan een memory-spel: de app toont kaartjes met slangwoorden op de ene helft en betekenissen op de andere, en de gebruiker moet paren vinden door om beurt twee om te draaien. Of galgje: de app kiest een slangwoord en de gebruiker raadt letters. Of een invuloefening: de app toont een zin met een slangwoord weggelaten en de gebruiker kiest het juiste woord uit een paar opties om de zin compleet te maken (“Die nieuwe telefoon is echt ___!” → opties: lit, skeer, chill). Deze spellen zijn optioneel en bedoeld om het leren luchtig te houden; ze zijn eenvoudig gehouden zodat ook minder technisch onderlegde ouders niet vastlopen. Er zijn bijvoorbeeld geen strenge timers of ingewikkelde bediening – tijdsdruk kan stress geven, dus indien er een tijdsgebonden element is, is dat optioneel of ruim genoeg. De quiz/spel-omgeving heeft grote knoppen voor de antwoorden, duidelijke voortgangsindicatoren (bijv. “Vraag 3 van 5”), en indien van toepassing een mogelijkheid om tussentijds te pauzeren of stoppen. De gebruiker kan altijd een quiz afbreken; bij voortijdig stoppen kan een bevestiging gevraagd worden (“Weet u zeker dat u wilt stoppen? De huidige quiz wordt dan niet opgeslagen.”) zodat per ongeluk afsluiten voorkomen wordt. Scoring & adaptiviteit: De quizzen en spellen zijn gekoppeld aan het beloningssysteem (zie Gamificatie). Voor elke voltooide quiz krijgt de gebruiker bijvoorbeeld 20 punten, plus extra punten per goed antwoord. Er is geen zware bestraffing voor fout – het ergste is dat men die punten misloopt – we willen de ervaring positief houden. Aan het eind van een quiz kan een samenvatting getoond (“8 van de 10 vragen goed!”) met eventueel aanbeveling welke woorden nog eens te bekijken (die 2 fouten). De moeilijkheid kan zich aanpassen aan de gebruiker: als iemand consequent hoge scores haalt, kan de app volgende keer lastigere of minder voorkennis vragen (meer nieuwe woorden, of bijvoorbeeld geen multiple-choice maar invullen). Omgekeerd, als iemand moeite heeft en veel fouten maakt, zou de app kunnen voorstellen kortere quizjes te doen of bepaalde woorden vaker laten terugkomen. Dit adaptieve mechanisme wordt bij voorkeur automatisch geregeld (de app houdt bij welke vragen fout gingen en biedt die later nogmaals aan), zodat de gebruiker vanzelf leermateriaal op maat krijgt. Edge cases: we zorgen dat bij een kleine woordenlijst de vragen niet te snel repetitief worden – de app heeft een ruime pool aan woorden nodig. Mocht een fanatieke gebruiker tientallen quizzen spelen en herhaalt zich onvermijdelijk iets, is dat op zich niet erg (herhaling is oefenen). Als alle antwoorden van een quiz fout zijn, krijgt de gebruiker een bemoedigende boodschap in plaats van niets: bijvoorbeeld “Dat was lastig! Bekijk de betekenis van de fout beantwoorde woorden nog eens en probeer opnieuw.”, zodat de gebruiker weet dat falen ook oké is en vooral een aanwijzing welke slang nog te leren is. De quizzen werken idealiter volledig offline (alle benodigde woorden zitten lokaal), zodat ook zonder internet de gebruiker kan oefenen. Mocht in de toekomst de quiz dynamisch vanuit een server nieuwe vragen laden, dan zorgen we voor een offline fallback (bijv. een laatste gedownloade quiz of melding dat offline geen nieuwe quiz mogelijk is). Ten slotte hebben we rekening gehouden met gezamenlijk gebruik: ouders kunnen zo’n quiz natuurlijk samen met hun tiener doornemen voor de lol. Dat kan gewoon op één apparaat; er is geen meerpersoonsmodus, maar niets verhindert samen naar het scherm kijken. We ondersteunen geen meerdere gebruikersprofielen in de app voor quizzen – de app is bedoeld als single-user ervaring (één ouder). Eventueel in de toekomst als er vraag naar is, zou een multi-account of gezinsmodus ontwikkeld kunnen worden, maar voor nu is dat buiten scope.

Gamificatie en Beloningen: Om de motivatie hoog te houden, bevat de app diverse gamification-elementen. Gebruikers verdienen punten voor acties, kunnen badges vrijspelen, stijgen in level en bouwen een streak op door dagelijks gebruik. Dit werkt als volgt. Bij elke relevante actie kent de app punten toe aan het profiel van de gebruiker. Voorbeelden van puntenwaarden: Het bekijken van het Woord van de Dag levert bijvoorbeeld 5 punten op (om dagelijks gebruik te belonen), een volledige quiz voltooien geeft ~20 punten, elk correct beantwoorde quizvraag nog eens 2 punten extra, en het indienen van een nieuw slangwoord (als community-bijdrage die goedgekeurd wordt) geeft bijvoorbeeld 10 punten. Ook zijn er bonuspunten voor het behalen van mijlpalen, zoals een streak van 7 dagen op rij (bijv. +15 punten eenmalig). Dit puntensysteem is configureerbaar, maar de logica is duidelijk: de app moet verschillende acties herkennen en bijhouden om de juiste hoeveelheid punten toe te voegen. De punten worden opgeslagen (lokaal of op de server bij het gebruikersprofiel) zodat ze bewaard blijven. Op basis van het totale puntenaantal heeft de gebruiker een bepaald level. Bijvoorbeeld: 0–49 punten is level 1, 50–199 punten level 2, 200–499 punten level 3, etc. De exacte drempels kunnen gewijzigd worden, maar het idee is dat in het begin levels vrij snel stijgen (zodat nieuwe gebruikers al snel level 2 halen en dat als beloning voelen) en naarmate de levels hoger worden er meer punten nodig zijn. Wanneer een gebruiker een nieuw level bereikt, toont de app meteen een felicitatie (“Gefeliciteerd, u bent nu Level 3: Slangkenner!”) en eventueel wordt een bijpassende badge toegekend. Badges zijn onderscheidingen voor speciale prestaties of mijlpalen. Er is een reeks badges gedefinieerd, bijvoorbeeld: Eerste Woord Opgezocht (na het eerste woord vertaald te hebben), Tien Woorden (na 10 verschillende opgezochte woorden), Eerste Quiz Voltooid, Quizmaster (5 quizzen voltooid met >80% goede antwoorden), Bijdrager (eerste community-woord ingestuurd), Weekstreak (7 dagen op rij geleerd), Maandstreak (30 dagen op rij), Slangautoriteit (bijvoorbeeld bij 1000 punten behaald). Deze badges hebben een naam en een bijbehorend icoontje. De app controleert bij elke relevante actie of een badge behaald is – zodra de criteria vervuld zijn, wordt de badge aan het profiel toegevoegd en krijgt de gebruiker direct een melding in de app (bijvoorbeeld een pop-up “Badge behaald: Weekstreak! Hou zo vol.”). In het profiel is een overzicht van alle behaalde badges (bijv. als een soort vitrinekast). Streak tenslotte is het aantal dagen achtereen dat de gebruiker actief is in de app. Als de gebruiker vandaag iets geleerd heeft (een Woord van de Dag bekeken, een vertaling gedaan of een quizvraag beantwoord), telt die dag mee in de streak. De volgende dag opnieuw activiteit verlengt de streak, etc. De streak wordt meestal in dagen geteld en weergegeven met bijvoorbeeld een vuurtje-icoon en het getal dagen (“🔥 5-daagse streak”). Ook wordt de langste streak tot nu toe bijgehouden (“Langste streak: 12 dagen”) zodat de gebruiker een persoonlijk record heeft om te proberen te verbreken. Slaat de gebruiker een dag over, dan valt de streak terug naar 0 en begint men opnieuw. Dit mechanisme motiveert dagelijkse betrokkenheid, maar we communiceren het op een positieve manier. Bijvoorbeeld, als iemands streak net verbroken is, gaan we de volgende dag niet plompverloren een teleurstellende boodschap sturen; in plaats daarvan stimuleren we een herstart (“Nieuwe dag, nieuwe kansen! Doe vandaag weer mee om een streak op te bouwen.”). Integratie in de UI: In de app zijn punten, levels, badges en streaks duidelijk maar niet hinderlijk aanwezig. Op het profielscherm ziet de gebruiker zijn totale punten en huidige level (met een voortgangsbalk tot het volgende level), de huidige streak en langste streak, en alle behaalde badges. Tijdens het gebruik verschijnen subtiele cues, bijvoorbeeld een kleine “+5” naast het Woord van de Dag als die geopend wordt (om te tonen dat punten zijn verdiend), of na een quiz een scherm met de score en “20 punten verdiend!”. Gamificatie wordt zo ingezet dat het leuk blijft maar niet verwarrend: alles wordt desgewenst uitgelegd via een helptekst of tijdens onboarding (“U verdient punten door woorden te leren en quizzen te spelen. Punten laten uw vooruitgang zien…” etc.). Voor gebruikers die gamification minder prettig vinden, kan eventueel in Instellingen een optie komen om bepaalde meldingen daarvan te minimaliseren. Randgevallen en anti-misbruik: Er is nagedacht over oneerlijk gebruik, al is de app niet competitief tussen gebruikers (er is géén openbare ranglijst of leaderboard, focus ligt op persoonlijk leren). Mochten gebruikers proberen te “grinden” voor punten – bijvoorbeeld steeds hetzelfde woord opzoeken of continu een quiz starten en afbreken – dan kan de app daar beperkingen inbouwen: bijvoorbeeld pas punten geven de eerste keer dat je op een dag een bepaald woord opzoekt, of alleen punten voor een quiz als die volledig is afgemaakt. Zo voorkom je dat iemand door oneindig te spammen onrealistisch veel punten krijgt (hoewel dat geen ander voordeel oplevert dan een hoger persoonlijk score). In de eerste versie vertrouwen we erop dat gebruikers vooral oprecht willen leren, dus deze anti-misbruikregels blijven eenvoudig. Data-consistentie is ook belangrijk: de app moet bijhouden wanneer en welke punten zijn toegekend zodat er niets dubbel of niets vergeten wordt – vooral als de logica deels op de client gebeurt en deels op een server. Als er bijvoorbeeld offline acties worden gedaan (punten lokaal tellen) die later met de server syncen, moet dat goed worden samengevoegd zonder dubbeltellingen. Mocht de gebruiker de app verwijderen zonder account, dan gaan de punten en badges lokaal verloren – daarom wordt in de communicatie aangeraden eventueel een account te maken als men veel progressie wil bewaren (zie Profiel). Een laatste ontwerpbeslissing is of gamification data lokaal of in de cloud beheerd wordt. Voor een MVP kan alle progressie lokaal opgeslagen worden (in een veilige opslag op het apparaat), wat eenvoudiger is maar riskanter voor dataverlies. Een cloud-backend met accounts maakt het persistenter en multi-device, maar is complexer. Dit is een open punt dat het ontwikkelteam in acht neemt; het systeem is in elk geval zo ontworpen dat het later uitgebreid kan worden met een backend zonder de hele app-logica te herschrijven.

Profiel en Adaptief Leren: De app bevat een profielsectie waar de gebruiker zijn persoonlijke voortgang kan inzien en voorkeuren kan instellen. In het profiel wordt basisinformatie getoond zoals de naam of gekozen gebruikersnaam, eventueel een profielfoto/avatar, maar vooral de leerstatistieken: hoeveel woorden geleerd/opgezocht, hoeveel quizzen voltooid en wat de gemiddelde score is, het totaal aantal punten en huidig level (met indicatie hoeveel tot het volgende level), de actuele streak en de behaalde badges. Dit geeft de ouder een duidelijk overzicht van zijn/haar vorderingen. Tevens kan de gebruiker via het profiel toegang krijgen tot favoriete woorden en eventueel een lijst van alle woorden die hij ooit heeft opgezocht of geleerd – een persoonlijke woordenlijst als naslag. Adaptief leren houdt in dat de app de moeilijkheid en inhoud aanpast aan de individuele gebruiker. In het ontwerp betekent dit bijvoorbeeld dat de app bijhoudt welke slangwoorden de gebruiker al goed beheerst en welke niet. Woorden die de gebruiker vaak fout had in quizzen of telkens opzoekt (dus lastig vindt) worden door het systeem gemarkeerd als “nog niet beheerst”; deze kunnen dan vaker terugkomen (bijvoorbeeld opnieuw verschijnen in een volgende quiz, of zelfs als Woord van de Dag om extra te oefenen). Omgekeerd hoeven woorden die iemand al meerdere keren goed had of vaak gebruikt niet steeds herhaald te worden – die worden als bekend beschouwd. Zo ontstaat een persoonlijk leerpad. De app zou ook een moeilijkheidsgraad kunnen toewijzen aan woorden (bij benadering: veelgebruikte slang vs niche-jargon) en aanvankelijk vooral gemakkelijke/populaire slang tonen, later zeldzamere of complexere termen als de gebruiker gevorderd raakt. Dit kan via een eenvoudig niveau-systeem (“Beginner slang” set vs “Gevorderde slang” set) of dynamischer via een score die stijgt/daalt met de prestaties. In de praktijk betekent adaptiviteit: als de gebruiker het heel goed doet, krijgt hij nieuwe of moeilijkere uitdagingen; als hij moeite heeft, krijgt hij wat meer herhaling en basismateriaal totdat het beter gaat. Deze adaptiviteit gebeurt grotendeels “onder water” – de interface blijft eenvoudig. Eventueel kan men in instellingen adaptief leren uitzetten of het systeem overrulen door zelf een niveau te kiezen (bijvoorbeeld “Geef me moeilijkere woorden” als iemand zich onderschat voelt, of andersom). Account en data-opslag: Het profiel kan in eerste instantie zonder inloggen werken, waarbij alle gegevens lokaal op het toestel worden bewaard. Dit vermijdt drempels voor gebruikers die geen account willen aanmaken. Wel waarschuwen we dat bij verwijderen van de app de data weg is. Optioneel kan de app aanbieden om een account te registreren (e-mail/wachtwoord of via Google/Apple sign-in) zodat de voortgang in de cloud wordt opgeslagen en eventueel gesynchroniseerd kan worden naar een ander apparaat. Bijvoorbeeld als een ouder zowel een telefoon als een tablet zou willen gebruiken – dan zorgt een account ervoor dat punten, favorieten, etc. overal gelijk zijn. Als dat scenario zeldzaam is, kan accountregistratie ook in versie 1 achterwege blijven. Privacy blijft belangrijk: als er accounts zijn, worden wachtwoorden veilig gehashed opgeslagen en alle communicatie met de server gaat via HTTPS. Ook zonder accounts zorgen we dat persoonlijke leerdata nooit ongewenst gedeeld wordt en alleen op het device blijft. De gebruiker moet duidelijk geïnformeerd worden welke data de app bijhoudt (woordopzoekingen, quizresultaten etc. voor eigen gebruik). In het profiel of instellingen kan een gebruiker ook kiezen om gegevens te wissen (recht om vergeten te worden). Instellingen: Via het profiel of een apart instellingenmenu kan de gebruiker allerlei voorkeuren aanpassen. Denk aan notificatie-instellingen (wil men de Woord van de Dag melding en/of de quiz-herinnering ontvangen, en op welke tijd), geluidsinstellingen (bijvoorbeeld geluidseffecten bij goede antwoorden aan/uit), lettergrootte of weergave-opties (misschien een schakelaar voor extra grote tekst of hoog contrast modus voor slechtzienden), en privacy-instellingen (zoals toestemming wel/geen anonieme gebruiksdata te delen voor verbetering van de app). Ook algemene info zoals de versie van de app, contactinformatie of een help-sectie is hier te vinden. Edge cases: Multi-gebruik op één apparaat is zoals gezegd niet voorzien – we gaan ervan uit dat de app per ouder gebruikt wordt. Als toch twee personen één telefoon delen, zullen ze elkaars voortgang zien; multi-user support is een mogelijke toekomstige uitbreiding via accounts. We bieden (voorlopig) ook geen expliciete “reset alle voortgang” knop, omdat dat niet echt nodig lijkt, maar mochten gebruikers hierom vragen kan dat als geavanceerde optie toegevoegd worden. Bij adaptief leren is nog belangrijk dat het systeem niet te snel conclusies trekt: één fout antwoord betekent niet meteen dat alles te moeilijk is, dus het algoritme moet geleidelijk aanpassen en eventueel zichzelf corrigeren. De gebruiker moet nooit het gevoel krijgen in een te kinderlijk niveau vast te zitten door een paar missers – daarom kan men altijd nog zelf kiezen uit content of instellen “ik wil moeilijkere quizzen”. Tot slot wordt de data van de gebruiker goed beveiligd lokaal of op de server. Zonder account staat de voortgang in een lokale database of opslag op het toestel; met account staat het op de server maar altijd gekoppeld aan de ingelogde gebruiker en niet publiek inzichtelijk. We houden ons aan de AVG: er wordt geen gevoelige persoonlijke info gevraagd, en eventueel voor analyses wordt data geanonimiseerd. Bij eerste gebruik doorloopt de gebruiker een korte onboarding waarin we bijvoorbeeld vragen hoe bekend hij al is met Straat-Praat (“helemaal nieuw – ken er al een paar – behoorlijk vertrouwd”) zodat het startniveau bepaald kan worden. Ook vragen we hier toestemming voor pushmeldingen en leggen we kort de functies uit (zoals wat het puntensysteem is). Dit onboardingproces houden we kort en helder, gezien de doelgroep van niet-tech-savvy ouders.

Pushnotificaties: De app gebruikt pushberichten op een vriendelijke, niet-opdringerige manier om gebruikers te herinneren en motiveren. Zoals genoemd is de belangrijkste notificatie het dagelijks Woord van de Dag. Daarnaast is er een streak-herinnering later op de dag als de gebruiker nog niets gedaan heeft (bijv. om 20:00 uur een bericht: “Je hebt vandaag nog geen nieuw woord geleerd. Bekijk nu het Woord van de Dag om je streak van 4 dagen vol te houden!”). Af en toe kan de app ook een quiz-uitnodiging sturen, bijvoorbeeld wekelijks: “🤔 Zin in een uitdaging? Doe een korte slangquiz en verdien punten!”. Als nieuwe content is toegevoegd kan een melding komen: “Er zijn 10 nieuwe woorden aan de lijst toegevoegd, neem een kijkje!”. En specifiek voor community-bijdragers: als iemands ingestuurde woord is goedgekeurd, krijgt die een persoonlijke notificatie: “Gefeliciteerd! Jouw ingestuurde woord ‘xyz’ is toegevoegd aan de Straat-Praat-app.”. De gebruiker heeft volledige controle over deze meldingen. Bij de eerste start vraagt de app om toestemming voor pushnotificaties met een duidelijke uitleg (“Mogen we u meldingen sturen voor het Woord van de Dag en leuke quiz-herinneringen? U kunt dit later altijd aanpassen.”). In het instellingenmenu kan men vervolgens alle notificaties in één keer uitzetten of juist per categorie aan/uit zetten (bv. dagwoord, streak, quiz, updates). Ook kan men hier het tijdstip voor de dagelijkse Woord-van-de-Dag melding instellen. Standaard is dat 10:00, maar misschien wil iemand het liever ’s avonds; we bieden een paar keuzemogelijkheden of een tijdkiezer. De app houdt ook rekening met niet storen in de nacht – standaard sturen we tussen 22:00 en 7:00 geen geplande meldingen, tenzij de gebruiker expliciet iets anders instelt, om slaap niet te verstoren. Technisch gezien gebruiken we een combinatie van lokale scheduling en servergestuurde notificaties. Veel meldingen (dagelijks woord, streak reminder, quiz reminder) kunnen de app zelf inplannen als lokale notificatie, zodat er geen permanente serverconnectie nodig is. Bij app installatie worden bijvoorbeeld gelijk timers gezet voor elke volgende dagwoord melding op het gekozen tijdstip. De app checkt dagelijks of de gebruiker die dag al actief is geweest om te beslissen of de streak-herinnering nodig is. Dit kan allemaal lokaal: de app kan intern een vlag bijhouden “vandaag actief ja/nee” en ’s avonds een notificatie sturen als nee. Voor sommige events die van de server komen (zoals “woord goedgekeurd” voor community-bijdrage of een grote batch nieuwe woorden toegevoegd) kan de backend een pushbericht sturen via Firebase/APNs gericht aan specifieke gebruikers of iedereen. Als in de eerste versie geen volwaardige backend draait, kunnen we deze meldingen ook anders oplossen – bijvoorbeeld dat de app pas bij openen laat weten “er zijn nieuwe woorden” in plaats van push. De teksten van de notificaties zijn kort en duidelijk, in informeel maar correct Nederlands. We gebruiken eventueel emoji’s ter verduidelijking en vrolijkheid (vuurtje voor streak, boekje voor woord leren, etc.), maar de kern van het bericht is altijd in tekst zodat het begrijpelijk is. We vermijden Straat-Praat in de notificatietekst zelf (behalve natuurlijk het woord van de dag) – het bericht moet uitnodigen om de app te openen waar de uitleg staat, niet al verwarren. Navigatie bij tikken: Via deep links zorgt de app dat bij het aantikken van een notificatie direct het relevante scherm opent: de Woord-van-de-Dag melding opent het Woord van de Dag scherm, een quiz-notificatie opent de quizsectie, een badge-melding opent het profiel of badges-overzicht, etc. Zo vindt de gebruiker meteen wat beloofd werd. Anti-spam: We limiteren het aantal notificaties strikt om niet opdringerig te worden. Doorgaans krijgt men maximaal één bericht per dag (het dagwoord). De combinatie dagwoord + streak-reminder op dezelfde dag wordt zo veel mogelijk vermeden of slim gecombineerd: bijvoorbeeld de streak-herinnering kan geïntegreerd worden in dezelfde melding (“Vandaag nog niet gekeken? Het woord van de dag skeer wacht op je!” in plaats van twee aparte berichten). Als een gebruiker de app uit zichzelf opent en het woord al gezien heeft, slaan we de geplande notificatie over zoals eerder beschreven. Bij langdurige inactiviteit sturen we hooguit na twee weken eens een berichtje en daarna laten we het rusten als er geen reactie komt. En uiteraard, als een gebruiker in de instellingen alle meldingen uit zet, respecteert de app dat volledig en zal niets meer sturen. Edge cases: Als de gebruiker geen toestemming geeft voor notificaties, werkt de app gewoon zonder die functie. We zullen niet blijven vragen; hooguit staat ergens subtiel “Mis geen dagelijks woord – schakel meldingen in (via Instellingen)” voor wie het handmatig aan wil zetten. Als iemand notificaties wel aanzet maar vervolgens op systeemniveau blokkeert, kan de app dat detecteren en in het instellingenmenu een melding tonen dat meldingen door de telefoon geblokkeerd zijn. Dat voorkomt verwarring (“waarom krijg ik niks?”). We hebben rekening gehouden met platformverschillen tussen iOS en Android in de implementatie (gebruik van hun respectievelijke notificatieschedulers en permissiedialogen). Verder voorzien we geen uitgebreide AI in de notificaties (zoals dat het systeem zelf lerend het beste tijdstip kiest), al zou in de toekomst wellicht mogelijk zijn om meldingen te timen op basis van gebruikspatroon (bv. als iemand steevast ’s avonds leert, ’s ochtends niks sturen). Voor nu houden we het bij de instelling door de gebruiker zelf. Ten slotte is het belangrijk dat notificaties altijd positief en motiverend blijven: als een streak verbroken is, zenden we daar geen “Jammer, je streak is weg”-bericht over, maar motiveren we de gebruiker liever om het weer op te pakken zoals genoemd.

Community-invoer & Moderatie: Omdat taal continu in beweging is, biedt de app gebruikers de mogelijkheid om zelf nieuwe slangwoorden aan te dragen die nog niet in de woordenlijst staan. Zo blijft de content actueel en betrekt het de community van ouders bij het uitbreiden van de kennis. De functionaliteit is als volgt: als de gebruiker een woord zoekt dat niet gevonden wordt (of via een menu-optie), kan hij via een formulier een nieuw woord indienen. Hij vult dan het slangwoord in, de (vermoedelijke) betekenis in gewoon Nederlands, en eventueel een context of voorbeeldzin waar hij het woord hoorde. Bijvoorbeeld: een vader hoort zijn kind zeggen “Dat feestje was kapot gaaf” en vindt “kapot” in die context niet in de app; hij kan “kapot (voor ‘heel erg’ in context)” insturen met uitleg “Mijn zoon zei dit om aan te geven dat iets erg gaaf was”. De app voert bij het indienen eerst een paar checks uit: het woordveld mag niet leeg zijn en moet uit hoofdzakelijk letters bestaan (geen lappen tekst of vreemde tekens). Ook wordt gekeken of het woord niet al bestaat in de database (een snelle zoek in de lokale woordenlijst); als het al voorkomt krijgt de gebruiker een melding “Dit woord staat al in de app” en eventueel een suggestie het via de vertaalfunctie op te zoeken. Hiermee voorkomen we dubbele inzendingen. Na de lokale validatie wordt de inzending verstuurd naar de server of cloud (Supabase). Als de gebruiker offline is op dat moment, bewaart de app de bijdrage lokaal in een wachtrij en verzendt hem zodra er weer internetverbinding is. Ingezonden woorden komen centraal binnen in een database-tabel voor community suggesties, met status “Nieuw”. Moderatieproces: Een aangewezen beheerder of moderator (bijvoorbeeld iemand van het contentteam) bekijkt alle nieuwe inzendingen via een aparte beheerinterface (buiten de mobiele app, bijvoorbeeld een eenvoudige web-admin). De moderator ziet een lijst van voorgestelde woorden met hun betekenis en context, en kan per item kiezen: Goedkeuren of Afkeuren. Bij goedkeuren wordt het woord overgenomen in de officiële slangwoordenlijst. Vaak zal de moderator hierbij nog een kwaliteitscheck doen: klopt de betekenis? Moet de beschrijving anders geformuleerd? Zijn er grofheden die anders verwoord moeten? De moderator kan de gegeven betekenis aanpassen of aanvullen. Ook kan hij bijvoorbeeld het woord categoriseren of koppelen aan bestaande varianten. Zodra een woord is goedgekeurd, krijgt het een plek in de hoofd-database (met alle velden als een normaal woord: definitie, voorbeeldzin, audio etc. – audio zal meestal nog ontbreken tot men dat toevoegt). Deze wijziging gaat mee in de eerstvolgende contentupdate naar alle gebruikers (zie Contentbeheer & Live Updates). Feedback naar gebruiker: indien de indiener bekend is (bijvoorbeeld de app weet e-mail of heeft een device ID, of de gebruiker is ingelogd), dan kan de app een bericht terugkoppelen. Idealiter ontvangt de gebruiker een pushmelding of in-app notificatie als zijn woord is goedgekeurd: “Jouw ingestuurde woord ‘XYZ’ is toegevoegd! Bedankt voor je bijdrage.”. Ook ontvangt hij dan de punten en/of badge (“Bijdrager”) die daarbij horen, wat direct zichtbaar wordt in zijn profiel. Bij afkeuren van een ingestuurd woord kan optioneel ook feedback gegeven worden, maar dat houden we laagdrempelig: vaak is het duidelijk (het woord bestond al, of de info was onvoldoende). We willen de gebruiker niet ontmoedigen, dus we zouden bij afwijzing ook niets kunnen sturen of hoogstens “Uw bijdrage is beoordeeld maar niet toegevoegd.” zonder in detail te treden. Beloning: Zoals genoemd bij Gamificatie krijgt een gebruiker voor een goedgekeurde bijdrage punten (bijv. +10) en als het de eerste keer is een badge (Bijdrager-badge). Dit om gebruikers te stimuleren zinnige bijdragen te leveren. Misbruikpreventie: Er is rekening gehouden met eventueel misbruik. Als iemand op het idee zou komen om ongepaste woorden of onzin massaal in te sturen, zal de moderator dit toch filteren en niet goedkeuren. Gebeurt het herhaaldelijk van dezelfde gebruiker (bij accounts) dan kan men overwegen die gebruiker te blokkeren voor verdere inzendingen. Zonder accounts is dit moeilijker, maar doordat de drempel voor onzin voor deze doelgroep al wat hoger ligt, verwachten we weinig spam. Inhoudelijk beleid: Straat-Praat kan grove termen bevatten en we weren die niet per se – als “kanker” of andere scheldwoorden gangbaar slanggebruik zijn met bepaalde betekenis, zullen we ze uiteindelijk willen opnemen maar voorzien van een nette uitleg (“kanker – zeer, extreem (als bijvoeglijk naamwoord gebruikt in jongerentaal, zeer in positieve of negatieve zin), voorbeeld: dat spel is kanker moeilijk = dat spel is ontzettend moeilijk.”). De moderatie zorgt ervoor dat zulke gevoelige woorden correct en niet aanstootgevend uitgelegd worden. Juridisch wordt in de gebruiksvoorwaarden van de app vermeld dat gebruikers bijdragen kunnen leveren en dat we die content mogen gebruiken/publiceren – dit is onderdeel van de privacyvoorwaarden/gebruikersvoorwaarden zodat alles netjes gedekt is. Edge cases: Het kan gebeuren dat meerdere gebruikers rond dezelfde tijd exact hetzelfde nieuwe woord insturen (bijv. een nieuw jongerenslangwoord gaat viral). In dat geval zal de moderatiequeue dat woord meerdere keren hebben. De moderator kan dan één inzending goedkeuren en de rest afwijzen als duplicaat. In de toekomst zouden we de admin-tool slim kunnen maken om dit te herkennen (“Er zijn 3 inzendingen voor chalant”) zodat de moderator ze kan samenvoegen of één kiezen. Beloningsgewijs krijgt dan waarschijnlijk alleen de eerste of degene met de beste beschrijving de punten; dat is een beleidskeuze (we kunnen niet iedereen punten voor hetzelfde woord geven, anders gaat men elkaar voor zijn). Een ander randgeval is dat de gebruiker mogelijk een verkeerd verstaan woord instuurt of een betekenis raadt die niet klopt. Dat is niet erg – moderatie corrigeert het en keurt dan eventueel goed met de juiste betekenis. De gebruiker leert dan alsnog wanneer het woord in de app verschijnt wat het echt betekent. Tot slot moeten we verwachtingsmanagement doen: ingediende woorden staan niet meteen in de app. Bij het indienen geven we een boodschap als “Bedankt voor uw suggestie! We zullen deze beoordelen en als het klopt toevoegen aan de woordenlijst (meestal binnen een paar dagen).” Zo weet de ouder dat het even kan duren en dat niet alles automatisch erin komt. Dit voorkomt frustratie bij het niet direct zien verschijnen. Over het al dan niet vereisen van een account voor bijdragen: om drempels laag te houden laten we ook anonieme bijdragen toe (dus zonder login). Dan is de bijdrage gekoppeld aan een device ID of gewoon anoniem. Het nadeel is dat we de gebruiker niet persoonlijk feedback kunnen sturen als het woord is toegevoegd; we zouden hoogstens in de app een algemeen bericht kunnen laten zien “Er zijn nieuwe woorden toegevoegd (misschien wel die van u!)”. Als de gebruiker echter een account heeft of zijn e-mail opgeeft, kunnen we gericht bedanken. Dit is een afweging tussen privacy/gebruiksgemak en feedbackloop. In eerste instantie neigen we naar geen account vereisen, dus anonieme bijdragen, en alleen feedback bij goedkeuring (push) als we de gebruiker kunnen identificeren. De punten kunnen we overigens ook bij anonieme gebruikers toekennen door ze lokaal op te slaan (gebonden aan device); alleen bij app verwijderen is dat dan weg. Schaalbaarheid: in het begin zal het aantal bijdragen beperkt zijn, maar als de app een groot succes wordt, kan moderatie veel werk worden. Dan moeten mogelijk extra moderators ingezet of community-voting systemen bedacht (bijv. dat meerdere gebruikers een nieuw woord kunnen bevestigen). Dat is voor nu niet aan de orde maar technisch is het systeem er klaar voor om uit te breiden (we hebben een duidelijke contributions-tabel met status e.d.).

Contentbeheer & Live Updates: De slangwoordenlijst die de app gebruikt moet gemakkelijk bijgewerkt kunnen worden door beheerders, zonder dat gebruikers een app-update hoeven te installeren. Daarom is er een contentmanagementsysteem voorzien. In de backend (bv. een Supabase PostgreSQL database) staan alle woorden met hun metadata. Beheerders kunnen via een aparte CMS-interface (bijvoorbeeld een beveiligde web-app) nieuwe woorden toevoegen, bestaande woorden wijzigen of fouten herstellen. Elke woordentry bevat velden als: slangwoord, betekenis (in het Nederlands), voorbeeldzin, een verwijzing naar een audio-opname (audio_url), eventueel categorieën of regio-tags, en een timestamp van laatste wijziging. De CMS-gebruiker kan records toevoegen of aanpassen. Als een woord niet meer relevant is, kan het gemarkeerd worden als inactief/verouderd – het wordt dan niet langer aan gebruikers getoond, maar blijft in de database voor naslag of eventueel historische verwijzing. De contentbeheerder kan ook bepalen welk woord de volgende dag Woord van de Dag wordt, indien gewenst: in het CMS kan een bepaald woord gepland worden voor een bepaalde datum. Als er niets gepland is, kiest de app automatisch iets willekeurigs zoals eerder beschreven. De technische kant van live updates houdt in dat de mobiele app periodiek controleert of er nieuwe of gewijzigde content is. Dit kan door bij het opstarten van de app een versienummer of timestamp van de lokale woordenlijst te vergelijken met die op de server. Bijvoorbeeld, de app slaat bij de laatste update een datum “2025-08-01” op. Bij start vraagt hij de server “is er een nieuwere versie sinds 2025-08-01?” via een API-call. Als ja, dan downloadt hij de nieuwe of gewijzigde woorden. Dit kan op twee manieren: delta-updates (alleen de verschillen, bijv. “deze 5 nieuwe woorden en 2 gewijzigde definities”) of gewoon de hele lijst opnieuw. Gezien de omvang van de lijst relatief klein is (enkele honderden tot paar duizend woorden, tekst is hooguit een paar honderd kilobyte), kan de app desnoods de hele woordenlijst ophalen bij elke update-check. We implementeren efficiënte updates (bijvoorbeeld via Supabase’s realtime mechanisme of een endpoint dat wijzigingen sinds een bepaalde datum teruggeeft) als dat kan, anders is volledige sync ook acceptabel. De app slaat de woordenlijst lokaal op (bijvoorbeeld in een SQLite database of IndexedDB) zodat zoeken en raadplegen supersnel en offline mogelijk is. De eerste keer dat de app wordt geïnstalleerd, zal hij die hele lijst moeten binnenhalen (eventueel tonen we een voortgangsbalk “Woordenlijst downloaden…” als het even duurt, maar vermoedelijk is het snel klaar). Daarna bij elke app-start of dagelijks op de achtergrond checken we 1x op updates. Door dit mechanisme hebben alle gebruikers altijd een up-to-date woordenboek zonder expliciet te updaten via de appstore. De oorspronkelijke Straatwoordenboek-app (iPhone app uit 2011) hanteerde ook al dagelijkse contentupdates – dat heeft toen goed gewerkt, en we bouwen voort op dat bewezen principe. De contentupdates verlopen uiteraard via een beveiligde verbinding (HTTPS) en we kunnen ervoor kiezen de updates cryptografisch te signeren zodat er geen kans is op gesjoemel (iemand zou theoretisch de verbinding kunnen spoofen om verkeerde data te sturen, al is dat zeer onwaarschijnlijk; toch is signing een mogelijke extra beveiliging). Notificatie bij contentupdate: Als er een hele grote update is (stel 100 nieuwe woorden toegevoegd), kan het contentteam besluiten een pushbericht te sturen om gebruikers daarop te attenderen (“Er is nieuwe slang beschikbaar, bekijk de nieuwste woorden!”). Dit is meer marketing/engagement; functioneel is het niet nodig omdat de app het toch laat zien bij zoeken. Maar het is een optie (push triggers vanuit het CMS). Quiz- en lescontent: De quizvragen worden direct uit de woordenlijst gegenereerd (slangwoorden en hun betekenissen vormen de basis van quizzen), dus er is geen separate vragenbank die onderhouden moet worden – één bron van waarheid is de woordenlijst. Mocht men in de toekomst speciale vaste quizzen of challenges willen toevoegen, dan kunnen die ook via het CMS beheerd worden (bijv. een set vragen als aparte content), maar voorlopig is dat niet nodig: de quiz is dynamisch. Taaluitbreiding: Momenteel is de content gericht op Nederlandse Straat-Praat en de interface is Nederlands. Als er ooit uitbreiding komt naar bijv. Vlaamse varianten of Engelstalige slang, kan het CMS model dat aan: bijvoorbeeld door een taal attribuut per woord toe te voegen (NL, EN, dialect X). De app zou dan bijvoorbeeld gefilterd op taal alleen de relevante slang tonen of de juiste TTS-taal kiezen. Dit is een toekomstscenario; nu is alles Nederlandstalig. Robuustheid: Als een contentupdate mislukt (bijv. halverwege downloaden valt internet weg), zal de app de oude dataset behouden en later opnieuw proberen. De gebruiker merkt hoogstens dat de nieuwste woorden een paar uur later pas verschijnen. In een log of melding kan “update mislukt, probeer later opnieuw” komen, maar idealiter draait de update op de achtergrond en probeert het vanzelf nogmaals. Ook als een gebruiker de app lange tijd niet opent en dan een heleboel updates mist, is dat geen probleem: de app zal gewoon de laatste versie ophalen (die omvat alle veranderingen cumulatief). We vermijden ingewikkelde delta-chains; waarschijnlijk vraagt de app gewoon altijd om de huidige volledige lijst, of de server geeft de huidige volledige lijst terug als de versie te ver achterloopt. We zorgen ervoor dat contentupdates onafhankelijk zijn van app-updates: d.w.z. iemand met een oudere versie van de app blijft gewoon woordenupdates ontvangen (tenzij er echt structurele wijzigingen in het datamodel zijn, maar dan moet de app uiteraard ook geüpdatet worden). Het ontwikkelteam voorziet eventueel een testmodus voor content – bijvoorbeeld een aparte ontwikkel-database of een flag zodat beheerders woorden kunnen toevoegen in een testomgeving om te kijken hoe ze in de app eruitzien voordat ze live gaan. Rollbacks zijn eigenlijk niet nodig: als er een fout in de content staat (bijv. een verkeerde definitie), dan corrigeert de contentbeheerder dat gewoon door een nieuwe wijziging (fix-forward). Tenslotte zorgt men dat de CMS-interface zelf gebruiksvriendelijk is, aangezien contentbeheerders wellicht geen technisch achtergrond hebben. Dus een simpel formulier, lijstweergaven met zoekfunctie, en eventueel bulk-importfunctionaliteit (bijv. als men in één keer 100 woorden uit een extern document wil importeren). Een specifieke noot is het beheer van audio en mediabestanden: als we uitspraak-opnames per woord ondersteunen, moet het CMS ook toestaan om een audiobestand te uploaden en te koppelen aan een woord. Waarschijnlijk slaan we zulke bestanden op in cloud storage (bij Supabase storage of S3), en bewaren we de URL in het woordrecord (zoals het veld audio_url). De app zal dan bij het tonen van een woord die URL gebruiken om de audio af te spelen (streamen of downloaden op verzoek). Bij contentupdates moeten we rekening houden dat audio niet altijd meegepakt wordt in één batch – we laten audio on-demand zodat we de app niet opblazen met grote bestanden. Dit betekent dat als een gebruiker op het audio-icoon drukt en het bestand is nog niet lokaal, de app het eenmalig download en afspeelt. Dit is acceptabel gezien de fragmenten kort zijn. We hebben hiermee alle content-gerelateerde zaken zodanig ingericht dat de app steeds actueel en boeiend blijft zonder de gebruiker lastig te vallen met technische updates.

AI-module (vertaalservice): Onder de motorkap maakt de vertaalfunctie gebruik van een AI-taalmodel om lastige vertalingen (vooral hele zinnen of onbekende slang) intelligent af te handelen. We hebben een dedicated vertaaldienst opgezet (bijvoorbeeld als aparte microservice) die via een API aangesproken wordt door de app/back-end. Deze service gebruikt een Large Language Model (LLM) zoals OpenAI’s GPT-4 of Anthropic’s Claude, of een eigen getraind model, gespecialiseerd in Nederlandse Straat-Praat. De prompt (instructie) voor dit model is zorgvuldig ontworpen zodat het model consistente en veilige vertalingen geeft. Het model wordt bijvoorbeeld geïnstrueerd met een systeemboodschap in de trant van: “Je bent een vertaalassistent die Nederlandse Straat-Praat omzet in formeel Nederlands en vice versa. Als de gebruiker slang invoert, geef de nette vertaling; als de gebruiker formeel Nederlands invoert, geef een informele slang-vertaling. Behoud de betekenis en toon, gebruik veelvoorkomende jongerentaal. Als een slangterm grof of beledigend is, vertaal die naar een neutrale omschrijving (geen nieuwe scheldwoorden toevoegen). Als je een term niet kent of twijfelt, geef dat aan (bijv. ‘(?)’ of zeg ‘mogelijk betekent dit X’) in plaats van iets te verzinnen. Geef het antwoord kort en bondig, idealiter alleen de vertaling.” Deze instructies zorgen dat het AI-model zich gedraagt als pure vertaler en niet afdwaalt of ongewenste output geeft. Omdat Straat-Praat soms schuttingwoorden bevat, hebben we expliciet gemaakt dat het model wel moet vertalen wat er staat (dus niet zomaar weigeren), maar dat het resultaat in net Nederlands mag omschrijven dat het om een scheldwoord gaat. Onbekende slang moet het model zo goed mogelijk uit context proberen te raden, maar mét een kenmerk van onzekerheid, zodat de gebruiker gewaarschuwd is dat het wellicht niet klopt. Bijvoorbeeld als iemand invoert “Die outfit is fleek”, en het model is niet 100% zeker, zou het kunnen antwoorden: “Die outfit is geweldig (vermoedelijk betekenis)” – dus het geeft een vertaling maar laat zien dat het de slang “fleek” niet volledig kent. Dit voorkomt dat er hallucinaties komen (het model iets volledig verkeerds verzint) en is onderdeel van het veilig prompten. Bij veel LLM’s is het zelfs nodig te benadrukken dat ze best “ik weet het niet” mogen zeggen – we hebben dat in de prompt gezet, zodat de AI niet met onzin komt maar eerlijk aangeeft als iets onbekend is. API-endpoints: De app/backend communiceert met deze AI-module via een paar REST API endpoints. Het belangrijkste is POST /translate. De client stuurt een JSON met de tekst om te vertalen en de doeltaalmodus. Bijvoorbeeld { "text": "Mag ik een vuurtje?", "target": "slang" } om die zin naar Straat-Praat om te zetten, of {"text": "Die chick is mijn fam", "target": "formal"} om slang naar normaal te gaan. We gebruiken expliciet een veld “target” met waarde "formal" of "slang" zodat de service niet zelf hoeft te raden wat de bedoeling is – de app weet immers in welke modus de gebruiker zit. (Alternatief hadden we een automatische detectie kunnen doen, maar dat is foutgevoelig, dus we kiezen voor expliciete modus of twee aparte endpoints /toSlang en /toFormal.) Het antwoord van /translate is ook JSON, bijvoorbeeld: { "translation": "Die meid hoort bij mijn familie", "confidence": 0.95 }. Hierin is translation de vertaalde tekst. We geven ook een confidence mee – een getal tussen 0 en 1 (95% zeker in dit voorbeeld) dat aangeeft hoe zeker de AI van zijn zaak is. Dit kan ook een kwalitatieve waarde “hoog/middel/laag” zijn. Desgewenst kan er nog een veld notes zijn waarin de service bijzonderheden noteert (bijv. “translated slang -> formal, offensive term toned down” of onzekerheid bij bepaalde woorden). In een minimale implementatie volstaan echter de vertaling en een confidence score. Het tweede endpoint is POST /feedback. Dit is bedoeld om gebruikersfeedback te registreren. De mobiele app kan na het tonen van een vertaling bijvoorbeeld vragen “Klopt deze vertaling?” met duim omhoog/omlaag. Als de gebruiker “incorrect” aangeeft, stuurt de app een call naar /feedback met bijv. {"original": "...", "translation": "...", "feedback": "incorrect"} (of een ID dat de vertaalactie identificeert, plus een vlag). De server kant slaat deze feedback op in een log of database voor latere analyse. Er is ook een simpel endpoint GET /health voorzien voor monitoring, dat gewoon “ok” teruggeeft als de service draait – zo kunnen we automatisch checken of de vertaaldienst online is. De communicatie met de AI-service gebeurt over HTTPS en in JSON formaat, wat gemakkelijk te parseren is in de app. We zorgen dat zowel input als output UTF-8 encodering ondersteunt, zodat ook emoji’s of bijzondere tekens in slang (denk aan “👊” of zo) goed doorkomen. Foutafhandeling in de vertaaldienst: We hebben meerdere lagen van foutafhandeling. Als de gebruiker een ongeldige aanvraag stuurt (bijv. JSON mist het text veld), retourneert /translate een 400 Bad Request met een duidelijke foutmelding in JSON, zodat de app eventueel aan de gebruiker kan melden dat er iets mis is met de invoer. Als de gebruiker extreem veel tekst invoert (meer dan de AI aan kan, zeg een heel lang verhaal), kan de service ervoor kiezen alleen de eerste zoveel karakters te vertalen of een 413 Payload Too Large fout terug te geven met de melding dat de tekst te lang is. Als de AI API van OpenAI/Claude zelf een error geeft – bijvoorbeeld een timeout, of de API-key is rate-limited – dan zal onze service dat opvangen. Er wordt eventueel één retry gedaan als het een timeout betreft. Als het echt niet lukt, geven we een 500 Internal Server Error terug aan de app. De app kan daarop bijvoorbeeld een generieke melding tonen (“Vertalen is momenteel niet beschikbaar, probeer het later nog eens.”). Belangrijk is dat zulke fouten gelogd worden met details, zodat ontwikkelaars weten dat er iets misging (bijv. “OpenAI API timeout at 15s”). Een ander scenario: het model geeft een antwoord terug dat niet in het verwachte formaat is. Ondanks onze instructies zou een LLM kunnen terugpraten (“Sure, I can translate that for you: ...”). Daarom hebben we validatie: als we JSON verwachten maar de respons is geen geldige JSON, probeert de backend de tekst te parseren of te corrigeren. We kunnen ook van de OpenAI API gebruikmaken van function calling of een verplicht JSON schema, zodat het model direct gestructureerd antwoordt. In het ideale geval dwingt dat het juiste formaat af. Als fallback als het toch niet helemaal klopt, kan de code proberen relevante stukken uit de tekst te halen. Mocht alles falen, dan kan de service eventueel nog een tweede poging doen met een hardere prompt (“antwoord alleen met JSON!”) of als uiterste een andere aanpak gebruiken (bijvoorbeeld een kleinere eigen vertaalslag of een statische woordenlijst als backup voor enkelvoudige woorden). Het belangrijkste is dat de app uiteindelijk iets van antwoord krijgt – desnoods een foutmelding – en niet blijft hangen. Geen vertaling gevonden: In zeldzame gevallen weet het model echt geen raad (de zin is bijv. onzin of bevat slang die zelfs na gok onbekend blijft). We hebben het model zo getraind dat het in zulke gevallen iets van onzekerheid zegt. Als de confidence heel laag zou zijn (onder een drempel, bijv. 0.2), kunnen we overwegen in plaats van een normaal antwoord een speciale melding terug te geven, zoals translation: "(Kon niet vertaald worden)" met confidence 0, zodat de app dat netjes kan tonen. Maar meestal zal het model zelf al iets van “(?)” in de output zetten bij grote twijfel, en geven we dat gewoon door. Confidence score bepaling: Zoals genoemd krijgt de gebruiker bij een vertaling een indicatie hoe betrouwbaar de vertaling is. Omdat een model als GPT niet vanzelf een waarschijnlijkheidspercentage geeft, lossen we dit via de prompt en heuristiek op. We vragen het model bijvoorbeeld om aan het eind van de vertaling tussen haakjes een trefwoord te zetten zoals (zekerheid: hoog), (zekerheid: middel) of (zekerheid: laag). De backend herkent dat en slaat het om naar een numerieke waarde (bijv. hoog = 0.9, middel = 0.5, laag = 0.2). Als we direct JSON laten genereren, kunnen we het model laten invullen "confidence": 0.xx op basis van zijn inschatting. Die inschatting baseert het model op hoe “vreemd” of onzeker de input klinkt. We ondersteunen dit eventueel met eigen logica: als de output bepaalde woorden zoals “misschien” of vraagtekens bevat, dan verlagen we de confidence. Ook kijken we of alle belangrijke woorden uit de input terugkomen in de output (als het model hele stukken weglaat, is dat verdacht). In toekomstige versies zouden we een geavanceerdere aanpak kunnen doen, bv. de prompt twee keer naar het model sturen en kijken of dezelfde vertaling terugkomt: als ja, dan vrij zeker; als elke keer iets anders, dan onzeker. Maar dat kost meer API-calls en doen we alleen als performance het toelaat. Voor nu vertrouwen we op de zelfinschatting van het LLM en eenvoudige checks. De confidence wordt in de JSON meegegeven aan de app, die er bijv. een icoontje (groen/oranje/rood lampje) van kan maken of een tekst “(onzeker)” kan tonen. Zo weet de ouder of hij de vertaling met een korreltje zout moet nemen. Leermechanisme en modelaanpassing: Deze AI-vertaler kan gaandeweg slimmer worden. We voorzien een paar dingen. Ten eerste een dynamisch woordenboek op de backend: stel meerdere gebruikers geven aan dat de vertaling voor een bepaald nieuw slangwoord telkens incorrect is, dan kan een taalexpert dat slangwoord met de juiste betekenis toevoegen aan een interne lijst. De vertaalmodule kan die lijst raadplegen bij iedere aanvraag. Concreet: als de gebruiker “ossow” invoert en dat woord staat in ons woordenboek als “ossow = geld (Straat-Praat, vervorming van ‘osso’ Surinaams voor huis, in context betekent het geld)”, dan kunnen we deze kennis in de prompt toevoegen (“NB: ‘ossow’ betekent geld.”) zodat het model het zeker goed vertaalt. Zo’n woordenlijst kan gevuld worden met alle slang die het model (nog) niet goed doet. Daarnaast verzamelen we via de genoemde feedbackfunctie een dataset van voorbeeldzinnen en de correcte vertalingen. Op termijn kunnen we het AI-model hiermee fine-tunen: we kunnen bijv. OpenAI’s GPT-3.5 fine-tunen met honderden paaren slang→normaal en normaal→slang in het Nederlands. Ook een opensource model (bv. mT5 of BLOOM) zouden we zelf kunnen trainen op die data. Fine-tuning zou de vertalingen nog accurater en sneller kunnen maken voor dit domein. We zorgen er wel voor dat door fine-tunen het model niet té eenzijdig wordt – het moet algemeen Nederlands nog kunnen, maar aangevuld met extra kennis van jongerentaal. Deze modelupdates hoeven niet continu te gebeuren; misschien eens in de zoveel tijd als er genoeg nieuwe data is. Reinforcement learning (bijv. een RLHF-proces waarbij het model leert van feedbackscores) hebben we geopperd maar dat is complex voor nu – we houden het bij supervised learning van verzamelde correcte voorbeelden. Feedbackloop in praktijk: Alle vertaalverzoeken en feedback worden gelogd (met respect voor privacy, zie hieronder). We kunnen uit de logs bijvoorbeeld halen dat het model moeite had met woord X omdat dat steeds een lage confidence gaf of altijd “laag” werd beoordeeld. Die inzichten gebruiken we om het prompt aan te passen of woorden toe te voegen aan het woordenboek, of bij fine-tuning extra nadruk op die voorbeelden te leggen. Zo wordt de vertaling steeds beter afgestemd op Straat-Praat. Logging & Privacy: In de AI-service loggen we belangrijke informatie voor debugging: iedere inkomende request (zonder de volledige zin als dat privacygevoelig is – of we maskeren bepaalde woorden zoals namen), de uitgaande prompt naar de AI en het antwoord (zodat ontwikkelaars kunnen zien wat het model deed en of het format klopte), en de feedback die terugkomt met een koppeling naar de oorspronkelijke request (bijv. via een ID). We anonimiseren waar mogelijk: mochten gebruikers volledige zinnen invoeren die persoonlijke informatie bevatten (“Hoi ik ben Jan en woon in …”), dan kunnen we proberen namen/adres te detecteren en in de log te vervangen door placeholders. We gebruiken de AI-service uitsluitend voor de vertaalfunctie; er wordt geen andere gebruikersdata naar derden gestuurd. Volgens OpenAI’s beleid wordt API-verkeer niet gebruikt om hun modellen te trainen en verwijderen zij de data na 30 dagen automatisch, wat gunstig is voor privacy. Als extra kunnen we bij OpenAI een data opt-out aanvragen zodat ze de data helemaal niet opslaan. In onze eigen database houden we de vertalingen en feedback mogelijk iets langer, maar ook dat is vooral om de service te verbeteren. We slaan bij voorkeur geen persoonsidentificerende gegevens op bij deze logs (dus geen account ID, of indien wel dan gehashed). In de app-informatie (privacyverklaring) wordt duidelijk vermeld dat gebruikersinvoer naar een externe AI-service gaat voor vertaling, en dat we anonieme feedback gebruiken om de vertaalfunctie te verbeteren. De hele communicatie vindt versleuteld plaats. Alleen geautoriseerde ontwikkelaars kunnen de logbestanden inzien, en ook dan alleen voor het doel van kwaliteitsverbetering. Samengevat zorgt de AI-module ervoor dat de vertaalfunctie van losse woorden uitbreidt naar zinnen en moeilijkere constructies, met behoud van een veilig en transparant karakter (onzekerheden worden aangegeven, ongepaste taal wordt geneutraliseerd, privacy van de gebruiker wordt gerespecteerd).

Automatische Dataverzameling (scraper): Naast bijdragen van gebruikers haalt het systeem ook proactief nieuwe slangwoorden van het internet. Er is een Python-script ontwikkeld dat periodiek publieke bronnen afstruint op zoek naar Straat-Praat. Dit script kan bijvoorbeeld dagelijks draaien (via een cronjob of scheduler) en kijkt naar platforms waar jongeren taalgebruik delen. Enkele bronnen die het script gebruikt: Reddit (specifieke subreddits zoals r/teenagers of r/Straat-Praat als die bestaat), misschien TikTok- of Twitter-API’s voor trending woorden (voor zover beschikbaar), en online slangwoordenboeken zoals Urban Dictionary voor Nederlandse inzendingen. De aanpak is modulair: voor elke bron is er een functie. Bijvoorbeeld fetch_slang_from_reddit haalt de nieuwste posts op van bepaalde subreddits via de Reddit JSON API en filtert de woorden daarin. Het script extraheert tekst uit posts (titel en inhoud) en splitst deze in woorden. Dan filtert het op woorden die waarschijnlijk slang zijn: bv. woorden langer dan 2 letters die niet in een standaard stopwoordenlijst voorkomen en die bepaalde kenmerken hebben (bijv. veelvoorkomende slangpatronen of afkortingen). Elk kandidaat-slangwoord onderwerpt het script aan twee controles voordat het geaccepteerd wordt: duplicaten en moderatie. Via Supabase (die onze PostgreSQL database achter de schermen is) checkt het script of het woord al in de woordenlijst staat (of al eerder gevonden is). Zo niet, dan gebruikt het de OpenAI Moderation API of een eigen lijst met verboden termen om te bepalen of het woord niet extreem ongepast of toxisch is. We willen wel echte slang, inclusief eventueel grove taal, maar we filteren bijvoorbeeld racistische termen of puur scheldwoorden zonder verdere waarde. Als het woord door deze filters komt, voegt het script het toe aan de “new_words” tabel in de database. Hierbij slaat het de volgende velden op: het woord zelf (de slangterm), de bron waar het gevonden is (bijv. "reddit/r/teenagers" of "UrbanDictionary" met eventueel een link), de datum waarop het gevonden is, en een stukje context (bijvoorbeeld een korte zin of het zinsfragment waarin het woord voorkwam, om later de betekenis te kunnen afleiden). Deze context kan moderators helpen begrijpen hoe het woord gebruikt werd. Het script logt zijn acties (aantal woorden gevonden, fouten bij verbinding etc.) zodat we in productie in de gaten kunnen houden of het werkt. Het is robuust gemaakt: als een bron tijdelijk niet reageert, wordt dat gelogd maar het script gaat door met de andere bronnen. Door de modulaire opzet kunnen we later makkelijk nieuwe bronnen toevoegen (stel er komt een openbare API van TikTok hashtags of YouTube comments). Dit geautomatiseerde verzamelen zorgt dat nieuwe slang die online in omloop komt snel op onze radar staat. Vervolgens kan een contentbeheerder deze binnengehaalde woorden bekijken (vergelijkbaar met community-inzendingen) en met één klik overzetten naar de officiële woordenlijst als ze legit zijn, inclusief het invoeren van de juiste definitie. Zo blijft de app up-to-date met minimale handmatige speurwerk. De eerste versie van het script richt zich op Reddit en Urban Dictionary, waar veel jongerentaal te vinden is. Het gebruikt libraries als requests (voor API calls), BeautifulSoup (voor HTML parsing indien nodig bij webpagina’s), en de Supabase Python client om direct in onze database te schrijven. Om die databasehandelingen veilig te doen, gebruikt het script een service-role API key van Supabase (alleen op de server, nooit in de app) waarmee het rechten heeft om de tabel bij te werken. De OpenAI API key voor moderatie wordt ook server-side gebruikt. We zorgen dat al deze keys als environment variables zijn ingesteld en niet hardcoded in het script. Dit dataverzamelscript draait bij voorkeur op een server of cloud function. In de logging meldt het bijvoorbeeld “Verbonden met Supabase database”, “15 nieuwe mogelijke slangwoorden gevonden op reddit, 3 toegevoegd, 12 gefilterd (7 duplicaten, 5 ongepast)”. Zo kunnen ontwikkelaars of beheerders het proces monitoren. Samengevat automatiseert dit script de eerste stap van contentverrijking: nieuwe slang opsnorren in het wild, filteren en klaarzetten in de database, zodat de contentmanager ze alleen nog maar hoeft te beoordelen en in te voegen.

Database & Zoeklogica (data-verrijking): De centrale woordenlijst in de database is slim gestructureerd om efficiënte zoekresultaten en flexibiliteit voor varianten te bieden. We hebben een PostgreSQL schema (via Supabase) met twee hoofdtabellen: words en word_variants. De words tabel bevat de lemma’s – dat zijn de hoofdvormen van elk slangwoord. Bijvoorbeeld de basisvorm “bro” (van brother) zou een record in words zijn, met kolommen: word (“bro”), meaning (“vriend, broer (als aanspreekvorm)”), example (“Bijv: ‘Hey bro, alles goed?’”), audio_url (link naar de audiofile als die er is), en metadata zoals created_at. Belangrijk: er zijn ook kolommen voor normalized_word en phonetic_primary / phonetic_secondary. Dit zijn velden voor zoekoptimalisatie. Normalized_word is het resultaat van een normalisatiefunctie die we op het woord toepassen: het woord wordt in lowercase omgezet, accenten verwijderd, speciale tekens eruit gefilterd, dubbele of langere herhalingen van letters gereduceerd (bijvoorbeeld “sooow” wordt “soow” – geen eindeloze herhalingen), en specifieke slang-heuristieken zoals een eindigend “-uh” vervangen door “-o” (“bruh” → “bro”). Dit maakt dat variaties zoals “brooo” of “bruh” uiteindelijk dezelfde genormaliseerde vorm “bro” opleveren. De phonetic_primary en secondary kolommen bevatten de uitkomst van het Double Metaphone algoritme op de genormaliseerde vorm – dit zijn codes die woorden met vergelijkbare klank dezelfde waarde geven. Zo krijgen “bro”, “brah”, “bruh” waarschijnlijk dezelfde phonetic code. Op de words tabel staat een database trigger die bij elke insert of update automatisch normalized_word en die phonetic velden vult aan de hand van het ingevoerde woord. Hierdoor is de data altijd consistent en hoeven we in queries niet steeds opnieuw te normaliseren – het is al opgeslagen. De tweede tabel word_variants bevat alternatieve spellingen of vormen. Bijvoorbeeld bij hoofdwoord “bro” kunnen varianten zijn “bruh”, “bruv”, “bra”. Elke variant heeft een verwijzing (foreign key) naar het hoofdwoord (word_id) en eigen kolommen variant (de variant string zoals “bruh”), variant_norm (genormaliseerde variant) en phonetic codes. Ook voor deze tabel zorgen triggers dat bij toevoegen van variant de genormaliseerde variant en phonetic codes worden ingevuld. Het idee is dat zowel de hoofdwoorden als hun varianten doorzoekbaar zijn op een uniforme manier. We hebben in de database Full-text search en trigram indexes geactiveerd: op words.normalized_word en word_variants.variant_norm staat een GIN-index met pg_trgm (trigram), zodat we snel fuzzy matches kunnen vinden. Tevens hebben we indexes op de phonetic velden zodat een gelijkheid op de Double Metaphone code efficiënt is. Met deze voorbereidingen is de zoekfunctionaliteit gerealiseerd via een opgeslagen functie search_words(q text). Deze functie (geschreven in SQL/PLpgSQL) neemt een zoekquery van de gebruiker, normaliseert die query meteen op dezelfde manier (lowercase, etc.), berekent de phonetic codes van de query, en zoekt vervolgens in beide tabellen naar overeenkomsten. Er wordt gekeken naar: exacte match (genormaliseerd precies gelijk), fuzzy match (via LIKE %...% of trigram similarity boven bepaalde drempel) en fonetische match (code komt overeen). De resultaten uit words (lemma’s) en variants worden gecombineerd, waarbij ook aangegeven wordt of een hit via een variant of direct lemma kwam. Bovendien wordt een score berekend om de relevantie te rangschikken: exacte match krijgt het hoogste (score 1.0), een puur fonetische match iets lager (bijv. 0.9) tenzij er ook een goede trigram overeenkomt. De functie gebruikt greatest() om de hoogste relevantie per kandidaat te bepalen van de verschillende criteria. Uiteindelijk geeft search_words een tabel terug met kolommen: word_id, word (de hoofdvorm), meaning, example, audio_url, match_on (‘lemma’ of ‘variant’) en de score. De app kan deze RPC via Supabase aanroepen. In JavaScript bijv.: supabase.rpc('search_words', { q: gebruikerQuery }). De eerste paar resultaten (gesorteerd op score desc) worden dan gebruikt voor de auto-aanvulsuggesties en om te bepalen wat te tonen. Dankzij deze aanpak kan de gebruiker bij het intypen van bijvoorbeeld “bra” meteen resultaten zien zoals “bro (gevonden via variant bra)” of “brakka” enz., ook als hij iets niet volledig of correct spelt. Als er via phonetic een resultaat is (bijv. gebruiker typt “ouwe” en het matcht fonetisch “auw” of zo), dan kan de UI eventueel een label tonen “gevonden op basis van uitspraak”. Wanneer geen resultaten gevonden worden (scorelijst leeg), dan weet de app zeker dat het woord ontbreekt en kan hij de “Voeg dit woord toe” prompt laten zien zoals eerder genoemd. Integratie varianten in contentbeheer: In het CMS kan de beheerder bij een woord ook varianten invoeren. Bijvoorbeeld bij “bro” voegt hij toe: variant “bruh”, variant “bruv”. Deze komen in de word_variants tabel en gaan dus mee naar de app bij de volgende contentupdate. De zoekfunctie zal dan vanaf dan ook “bruh” herkennen en direct naar “bro” verwijzen. Dit sluit aan bij de ontwerpwens om alternatieve spellingen en veelvoorkomende Straat-Praatvarianten vindbaar te maken. Ook audio is op deze manier geregeld: het veld audio_url in words is bedoeld om een downloadlink naar een geluidsbestand (mp3) op te slaan. De contentbeheerder kan per woord een audio-opname uploaden (bijv. een jongere die het woord uitspreekt). De app streamt die als de gebruiker op het audio-icoon drukt. Als er voor een woord (nog) geen audio beschikbaar is, gebruikt de app de tekst-naar-spraak van het device als fallback. In de praktijk betekent dat: als audio_url leeg is of het bestand niet bestaat, roept de app de native TTS aan om het woord te spreken (in Nederlands of Engels afhankelijk van het woord – veel Straat-Praat bevat Engelse woorden, dus we kiezen dan de stem die het best past). Dit is ook geïmplementeerd: de app checkt bij het afspelen of er een audio_url is; zo ja, dan laadt hij dat mp3’tje via een audio player; zo nee, dan doet hij speak(word, language) met de system TTS. Kwaliteitsheuristieken in zoeken: Om te voorkomen dat er te veel irrelevante fuzzy hits komen (trigram search kan soms woorden teruggeven die er nauwelijks op lijken), kan de functie een drempel hanteren: bv. alleen resultaten met similarity boven 0.3 of 0.4 worden getoond. Ook worden de resultaten al gesorteerd naar relevantie: exacte matches bovenaan, dan dicht-in-de-buurt, dan verre matches. De SQL greatest(case exact, similarity, case phonetic) zorgt daarvoor. Hierin is zo gekozen dat een fonetische match een score ~0.92 krijgt, wat doorgaans hoger is dan een vage trigram match maar lager dan een echte exacte match. Zo komt bijvoorbeeld “bruh” vs “bro” (phonetic match) hoog, maar niet hoger dan als iemand exact “bro” had getypt. Deze parameters kunnen we tunen op basis van tests. We hebben de normalisatie al uitgebreid met belangrijke patronen (eind-‘h’ eraf als die na een medeklinker komt, etc.). We kunnen die functie verder uitbreiden als blijkt dat in data veel andere variaties zitten (bv. ‘y’ vs ‘i’ in spelling, “kk” als intensifier die als “k” moet tellen, etc.). Omdat het een pluggable functie is, kunnen developers hier verbeteringen doorvoeren zonder de rest van de app te raken. Voice-in en Voice-out aanvullend: Zoals eerder vermeld is spraakinput en –output een onderdeel van de functionaliteit. In de context van de zoekfunctie betekent dat: bij voice-in drukt de gebruiker op het microfoonicoon naast de zoekbalk, de app vraagt toestemming voor microfoon als dat nog niet gegeven is, en start dan de spraakherkenning in Nederlands (of eventueel auto-detect Nederlands/Engels). De herkende tekst wordt direct in de zoekbalk geplaatst en triggers dezelfde search_words query. Meestal is dit voor één woord. (De gebruiker zou ook een hele zin kunnen inspreken; in dat geval stuurt de app dat naar de AI vertaalmodule in plaats van de woordenboek zoekfunctie – dit onderscheid is er in de UI via de toggles.) Voor voice-out (uitspraak) is reeds aangegeven: de app probeert eerst een menselijke opname te gebruiken. Daarom worden in de contentupdates de audio_url’s meegegeven. Die verwijzen bijvoorbeeld naar een bestand in Supabase storage, zoals https://<storage-url>/audio/word123.mp3. De app heeft een component die dat streamt en afspeelt als de gebruiker op het luidspreker-icoon drukt. Voor woorden zonder opname roept de app de TextToSpeech API van het device aan. Dit alles is transparant voor de gebruiker – hij drukt gewoon op 🔊 en hoort het woord uitgesproken. We geven in de UI eventueel een laadindicatie als het audiofile aan het streamen is zodat de gebruiker weet dat er geluid aankomt. Voorbeeld end-to-end: Neemt de gebruiker nu de proef op de som en typt (of spreekt) “bruh” in de zoekbalk. De app normaliseert “bruh” tot “bro”, zoekt in de woordenlijst en vindt dat “bro” bestaat (als lemma) en dat “bruh” ook als variant geregistreerd staat bij “bro”. De search_words functie retourneert “bro” met hoge score, match_on variant. De app toont direct “bro – betekent: vriend (afkomstig van ‘brother’)” enz. De gebruiker ziet dus het resultaat alsof hij “bro” had gezocht. Hadden we “bruh” niet als variant gehad, dan zou de phonetic match alsnog “bro” kunnen opleveren, zij het iets minder zeker. In elk geval krijgt de gebruiker een correct antwoord. Is er geen match, dan biedt de app de mogelijkheid om het woord aan te dragen. Deze hele zoek- en vertaalfunctionaliteit is nu consistent met wat in het functioneel ontwerp beoogd was (fuzzy search is hiermee gerealiseerd).

Technische Architectuur & Uitbreidingen: De applicatie is opgezet als een monorepo met zowel de frontend (mobile app) als de backend in één project, plus de nodige configuraties voor infrastructuur. De codebase heet bijvoorbeeld “straatpraat” (werknaam van het project) en bevat een map apps/ met daarin mobile en backend, en eventueel admin voor het beheerderspaneel. De mobiele app is gebouwd in React Native (JavaScript/TypeScript) zodat deze op zowel iOS als Android draait met één codebase. Er wordt gebruikgemaakt van React Navigation voor de schermnavigatie (tabs, stacks), Redux Toolkit of context API voor state management (bv. om globale staat als profiel en punten bij te houden), en een UI-bibliotheek zoals NativeBase om consistente, toegankelijke componenten (knoppen, tekstvelden, etc.) te hebben. Voor netwerkverzoeken in de app wordt bijvoorbeeld Axios gebruikt of direct de Supabase SDK voor databasecalls. De app kan communiceren met de backend via GraphQL API’s of direct met Supabase (voor bepaalde eenvoudigere queries zoals de woordenzoekfunctie via RPC). De backend draait op Node.js met NestJS (TypeScript) als framework. NestJS is gekozen om een modulaire, gestructureerde serverapplicatie te hebben. We hebben hierin modules voor verschillende domeinen: bv. een TranslationModule, UserModule, DictionaryModule, LearningModule etc., die elk de resolvers/controllers, services en data-access bevatten voor dat stukje functionaliteit. De primaire interface die de mobiele app aanspreekt is een GraphQL API (via Apollo Server in NestJS). Dit GraphQL schema definieert queries en mutaties zoals translate(text, target), getWord(id), searchWords(query), submitContribution(word, meaning, context), getProfileData, updateSettings, etc. Hierdoor kan de app flexibel data opvragen en wordt over-fetching verminderd (de app kan precies de velden selecteren die het nodig heeft). Voor real-time notificaties of updates zou ook gebruikgemaakt kunnen worden van GraphQL Subscriptions of Supabase’s realtime mechanisme, maar in deze fase is dat nog beperkt gebruikt (pushnotificaties verlopen via de systemen van Apple/Google, niet via GraphQL). De backend is verbonden met een PostgreSQL database (de Supabase instance). NestJS gebruikt bijvoorbeeld TypeORM of Prisma als ORM/Database client om de tabellen words, word_variants, users, contributions etc. te benaderen, hoewel we in sommige gevallen ook direct via Supabase RPC werken. Voor caching van veelgebruikte data en als message-queue wordt Redis ingezet. Bijvoorbeeld de vertaalservice resultaten (AI vertalingen) kunnen kort in Redis worden bewaard, zodat als twee gebruikers kort na elkaar dezelfde zin vertalen we de tweede keer direct het antwoord hebben. Ook sessie-informatie of throttle-counters kunnen in Redis. Daarnaast gebruikt de backend een Redis-gebaseerde queue (via Bull bijvoorbeeld) om achtergrondtaken af te handelen, zoals het periodiek draaien van het dataverzamelscript of het verzenden van batch-notificaties. AI/ML integratie: Het zware AI-model voor zinsvertaling draait in een aparte service geschreven in Python (bijv. FastAPI). Deze ML-service laadt een getraind transformer model (zoals een fine-tuned mT5 of GPT-variant) en biedt een HTTP API (/translate) dat NestJS aanroept. De reden voor aparte service is dat machine learning modellen veel geheugen gebruiken en in Python makkelijker te beheren zijn met PyTorch, plus zo kan het onafhankelijk schalen. Het model zelf (stel mT5) is getraind met HuggingFace Transformers en draait via TorchServe of onnx-runtime voor performance. De NestJS backend’s TranslationService stuurt een request naar deze ML-service wanneer een GraphQL vertaalquery binnenkomt, en krijgt de vertaling + meta terug. Deze wordt dan door NestJS naar de GraphQL-response omgezet richting app. We hebben ook een Voice Service conceptueel – in de architectuurdiagram is een voice-service die spraakherkenning en -synthese zou kunnen coördineren. In de praktijk gebeurt spraakherkenning op het device (via RN libraries) en TTS ook device-native, dus die “service” is meer een module in de app dan een aparte microservice. Gebruikersbeheer: Accounts en profieldata kunnen door NestJS afgehandeld worden (bijvoorbeeld via NestJS JWT auth of via Supabase Auth). Als Supabase Auth wordt gebruikt, registreert/inlogt de app direct met Supabase (dat levert JWT’s), en de NestJS backend vertrouwt die JWT via een middleware zodat GraphQL requests geauthenticeerd zijn. De user data (punten, instellingen, enz.) staat in de PostgreSQL en is via zowel Supabase als NestJS beschikbaar. Admin panel: Er is ook een los admin-panel (bijv. een kleine React web app) waarmee content beheerders via hun browser woorden kunnen bewerken en bijdragen modereren. Deze admin-app spreekt ook de backend (GraphQL of REST endpoints met admin authenticatie) of direct Supabase if privileges are set. De projectstructuur in de monorepo bevat daarvoor een admin-panel app. Infrastructure & deployment: In de repo is een docker/ directory met Dockerfiles en configuraties om de verschillende onderdelen containerized te draaien. Er is bijvoorbeeld een Dockerfile voor de NestJS backend en één voor de ML-service. We gebruiken multi-stage builds (eerst npm ci & build, dan runtime image minimaliseren). Er zijn ook Kubernetes manifests in k8s/ map voor als we in productie Kubernetes willen gebruiken. Continuous Integration/Deployment (CI/CD) is ingericht zodat bij nieuwe commits de tests automatisch draaien en er eventueel automatisch een nieuwe build naar een server gaat. Waarschijnlijk via GitHub Actions of GitLab CI: het pipeline-script doet bijvoorbeeld npm ci, npm run build voor backend en app, en kan zelfs unit tests en linting draaien. Voor de mobiele app is er wellicht een Fastlane setup om builds naar TestFlight/Play Store te pushen. Testing: Er is aandacht besteed aan een teststrategie. Unit tests zijn geschreven voor kritieke functies, bijvoorbeeld de TranslationService (in NestJS) heeft tests die met een stub AI-service werken om te controleren of juiste API-calls en foutafhandeling gebeuren. Ook de normalize_slang functie in de database is getest met voorbeeldinput (“bruuuuh” wordt “bruuh” etc.). Verder zijn er integratietests voor de GraphQL API (bv. met een in-memory database of test schema) om te zien of queries de verwachte data teruggeven. Performance tests kunnen gedaan worden met een script dat bijv. 100 vertalingen na elkaar doet om te meten of caching werkt en hoe de responstijd is. Daarnaast zal in een later stadium gebruikerstesten plaatsvinden – met een paar ouders laten proefdraaiien – maar technisch is er al gezorgd voor telemetrie en logging zodat problemen boven water komen. Monitoring van de productie gebeurt via logging (console logs en externe monitoring service) en eventueel pings naar het health endpoint. Caching via Redis zorgt dat de app vlot blijft, bijvoorbeeld als veel gebruikers tegelijk het Woord van de Dag laden, kan dat woord en zijn vertaling even in cache staan. Uitbreiding: Generatieve zinsvertaling & Leermodule: In de loop van het project zijn twee grote uitbreidingen doorgevoerd: ten eerste is de vertaalfunctie uitgebreid van losse woorden naar volledige zinnen met behulp van een eigen ML-model (zoals mT5). Dit betekent dat de NestJS GraphQL endpoint translate nu onderscheid maakt: voor zinnen langer dan één woord schakelt hij de Python ML-inference service in, terwijl hij voor een enkel woord eventueel een direct databanklookup of simpele translatie kan doen. De resultaten van de ML-vertaling bevatten naast de vertaalde zin ook extra informatie: het model kan bijvoorbeeld alternatieve vertalingen aanbieden (andere manieren om de zin te zeggen in Straat-Praat of in formeel taalgebruik) en een korte uitleg van specifieke termen. We slaan alle output op in een translation_history tabel (met velden: gebruiker, oorspronkelijke zin, vertaling, alternatieven, uitleg, confidence, timestamp). Zo heeft de gebruiker een geschiedenis van zijn vertalingen en kunnen we later ook inzicht krijgen welke zinnen vaak vertaald worden. We hebben tevens de integratie met TTS voor zinnen gerealiseerd: na een succesvolle vertaling roept de backend een text-to-speech functie aan (bijv. Google Cloud TTS of een device TTS via de app) om een audiofragment van de vertaalde zin aan te maken. In het resultaat (GraphQL type TranslationResult) zit dan een veld audioUrl dat de app kan gebruiken om een “uitspreken” knop voor de volledige zin aan te bieden. Deze audio wordt ofwel on the fly gegenereerd en geüpload naar storage, of op verzoek via het device gedaan. Dankzij caching in Redis hoeven we dezelfde zin niet telkens opnieuw door het dure model te sturen – bij herhaalde vertaalverzoeken kan de cache geschekte resultaten teruggeven. De tweede uitbreiding is een Duolingo-achtige leermodule die losse lessen en quizzen aanbiedt los van de dagelijkse willekeur. Er is nu een nieuw tabblad “Leren” in de app met een lessenoverzicht. Elke les bevat bijvoorbeeld 5 tot 10 slangwoorden gegroepeerd thematisch of op niveau. De gebruiker kan een les kiezen (bijv. “Les 1: Straat-Praat Basis” met basiswoorden als chill, doekoe, skeer, …). De les start dan een reeks quizvragen gericht op die woordenset. Dit is geïmplementeerd in een QuizScreen component dat voor de gekozen les een lijst vragen genereert. Die vragen variëren: definitievragen (Wat betekent X?), invulzinnen met een van de leswoorden, etc., zoals eerder conceptueel beschreven. Tijdens de les-quiz worden de antwoorden van de gebruiker bijgehouden en zo nodig herhaald: als de gebruiker een vraag fout beantwoordt, wordt dat woord later in dezelfde quiz nogmaals gevraagd (eventueel in een iets andere vorm) om zeker te stellen dat de gebruiker het alsnog leert – dit is spaced repetition binnen de sessie. Bij meerdere goede antwoorden op rij kan de moeilijkheid iets stijgen, bijvoorbeeld minder hulp bij het invullen. Deze adaptiviteit binnen de les is geïnspireerd door Duolingo’s methode om fouten meteen te laten herkansen en successen uit te bouwen. Aan het eind van de les krijgt de gebruiker een resultatenoverzicht en worden punten toegekend voor het voltooien van de les (en de juiste antwoorden). Deze punten tellen op bij zijn profiel. Ook kunnen specifieke badges gekoppeld zijn aan de leermodule, bijv. “Eerste les voltooid!” of “5 dagen achtereen geleerd” (streak-badge die parallel loopt aan de Woord-van-de-Dag streak, maar nu specifiek op lessen). In het profielscherm is daarom uitgebreid: naast de algemene stats ziet de gebruiker nu ook zijn voortgang in de leermodule – bijvoorbeeld hoeveel lessen voltooid, welke laatste score voor een les, enz. De badges, punten, streaks zijn geïntegreerd zodat zowel het gebruik van losse functies (dagelijkse woorden, quiz) als de gestructureerde lessen bijdragen aan één samenhangend voortgangssysteem. Technisch betekende dit dat we nieuwe frontend-schermen toevoegden (LessonListScreen, QuizScreen) en de navigatie uitbreidden met een tab of menu-item “Leren”. In de backend/database hebben we tabellen voor lessen en lesinhoud toegevoegd of we genereren de lesinhoud on the fly uit de bestaande woordenlijst (in de eerste implementatie is het simpel: lessen zijn hard-coded lijsten van woorden in de app, later kan dit via CMS komen). De progressie (welke lessen gedaan, scores) wordt bijgehouden in de lokale opslag of in de database per gebruiker. Ook werden de bestaande systemen hergebruikt: de quiz in de leermodule gebruikt dezelfde vraaggenerator-logica als de reguliere quiz, alleen gefilterd op de leswoorden. Gamificatie sluit naadloos aan: een les voltooien triggert dezelfde punten/badge mechanieken. Overkoepelend ontwerp: De technische architectuur is daarmee modulair en schaalbaar. We hebben een mobiele app die via GraphQL en Supabase RPC’s communiceert met een NestJS backend en direct met de database waar nodig. De zware ML-taken zijn ausgelagerd aan een Python service. Data staat centraal in PostgreSQL (via Supabase voor gemak van auth en realtime). Redis zorgt voor snelheid en asynchrone taken. CI/CD zorgt dat we constant kunnen deployen en testen. En de code is gestructureerd in één repository, wat ontwikkeling efficiënt maakt (shared types en componenten tussen frontend en backend zijn mogelijk via een /packages directory met gedeelde modules). Alles is ingericht conform het hierboven beschreven functioneel ontwerp: alle concepten (vertaalfunctie, woord van de dag, quizzen, gamificatie, adaptief leren, notificaties, community content, up-to-date woordenlijst) zijn in de implementatie aanwezig en alle parameters en stromen (zoals API endpoints, input/output format, search algoritmes, feedbackloops, puntentelling, enz.) zijn duidelijk vastgelegd zodat de app-ervaring soepel en volgens ontwerp verloopt.